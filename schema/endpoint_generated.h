// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENDPOINT_IROHA_H_
#define FLATBUFFERS_GENERATED_ENDPOINT_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "commands_generated.h"
#include "main_generated.h"
#include "primitives_generated.h"
#include "transaction_generated.h"

namespace iroha {

struct Response;

struct Ping;

struct CheckHashResponse;

struct PeersResponse;

struct AssetQuery;

struct AssetResponse;

struct TxWithIndex;

struct TxRequest;

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_CODE = 6,
    VT_SIGNATURE = 8
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  iroha::Code code() const {
    return static_cast<iroha::Code>(GetField<uint8_t>(VT_CODE, 0));
  }
  bool mutate_code(iroha::Code _code) {
    return SetField<uint8_t>(VT_CODE, static_cast<uint8_t>(_code), 0);
  }
  const iroha::Signature *signature() const {
    return GetPointer<const iroha::Signature *>(VT_SIGNATURE);
  }
  iroha::Signature *mutable_signature() {
    return GetPointer<iroha::Signature *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response::VT_MESSAGE, message);
  }
  void add_code(iroha::Code code) {
    fbb_.AddElement<uint8_t>(Response::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_signature(flatbuffers::Offset<iroha::Signature> signature) {
    fbb_.AddOffset(Response::VT_SIGNATURE, signature);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    iroha::Code code = iroha::Code::COMMIT,
    flatbuffers::Offset<iroha::Signature> signature = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    iroha::Code code = iroha::Code::COMMIT,
    flatbuffers::Offset<iroha::Signature> signature = 0) {
  return iroha::CreateResponse(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      code,
      signature);
}

struct Ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_SENDER = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  flatbuffers::String *mutable_sender() {
    return GetPointer<flatbuffers::String *>(VT_SENDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyOffset(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Ping::VT_MESSAGE, message);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(Ping::VT_SENDER, sender);
  }
  PingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingBuilder &operator=(const PingBuilder &);
  flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ping> CreatePing(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0) {
  PingBuilder builder_(_fbb);
  builder_.add_sender(sender);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ping> CreatePingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const char *sender = nullptr) {
  return iroha::CreatePing(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      sender ? _fbb.CreateString(sender) : 0);
}

struct CheckHashResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISCORRECT = 4,
    VT_ISROOT = 6,
    VT_ISEXIST = 8
  };
  bool isCorrect() const {
    return GetField<uint8_t>(VT_ISCORRECT, 0) != 0;
  }
  bool mutate_isCorrect(bool _isCorrect) {
    return SetField<uint8_t>(VT_ISCORRECT, static_cast<uint8_t>(_isCorrect), 0);
  }
  bool isRoot() const {
    return GetField<uint8_t>(VT_ISROOT, 0) != 0;
  }
  bool mutate_isRoot(bool _isRoot) {
    return SetField<uint8_t>(VT_ISROOT, static_cast<uint8_t>(_isRoot), 0);
  }
  bool isExist() const {
    return GetField<uint8_t>(VT_ISEXIST, 0) != 0;
  }
  bool mutate_isExist(bool _isExist) {
    return SetField<uint8_t>(VT_ISEXIST, static_cast<uint8_t>(_isExist), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISCORRECT) &&
           VerifyField<uint8_t>(verifier, VT_ISROOT) &&
           VerifyField<uint8_t>(verifier, VT_ISEXIST) &&
           verifier.EndTable();
  }
};

struct CheckHashResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isCorrect(bool isCorrect) {
    fbb_.AddElement<uint8_t>(CheckHashResponse::VT_ISCORRECT, static_cast<uint8_t>(isCorrect), 0);
  }
  void add_isRoot(bool isRoot) {
    fbb_.AddElement<uint8_t>(CheckHashResponse::VT_ISROOT, static_cast<uint8_t>(isRoot), 0);
  }
  void add_isExist(bool isExist) {
    fbb_.AddElement<uint8_t>(CheckHashResponse::VT_ISEXIST, static_cast<uint8_t>(isExist), 0);
  }
  CheckHashResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckHashResponseBuilder &operator=(const CheckHashResponseBuilder &);
  flatbuffers::Offset<CheckHashResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CheckHashResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckHashResponse> CreateCheckHashResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool isCorrect = false,
    bool isRoot = false,
    bool isExist = false) {
  CheckHashResponseBuilder builder_(_fbb);
  builder_.add_isExist(isExist);
  builder_.add_isRoot(isRoot);
  builder_.add_isCorrect(isCorrect);
  return builder_.Finish();
}

struct PeersResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_PEERS = 6,
    VT_SENDER = 8
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>> *peers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>> *>(VT_PEERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>> *mutable_peers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>> *>(VT_PEERS);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  flatbuffers::String *mutable_sender() {
    return GetPointer<flatbuffers::String *>(VT_SENDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyOffset(verifier, VT_PEERS) &&
           verifier.Verify(peers()) &&
           verifier.VerifyVectorOfTables(peers()) &&
           VerifyOffset(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           verifier.EndTable();
  }
};

struct PeersResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(PeersResponse::VT_MESSAGE, message);
  }
  void add_peers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>>> peers) {
    fbb_.AddOffset(PeersResponse::VT_PEERS, peers);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(PeersResponse::VT_SENDER, sender);
  }
  PeersResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeersResponseBuilder &operator=(const PeersResponseBuilder &);
  flatbuffers::Offset<PeersResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<PeersResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PeersResponse> CreatePeersResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Peer>>> peers = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0) {
  PeersResponseBuilder builder_(_fbb);
  builder_.add_sender(sender);
  builder_.add_peers(peers);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeersResponse> CreatePeersResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<flatbuffers::Offset<iroha::Peer>> *peers = nullptr,
    const char *sender = nullptr) {
  return iroha::CreatePeersResponse(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      peers ? _fbb.CreateVector<flatbuffers::Offset<iroha::Peer>>(*peers) : 0,
      sender ? _fbb.CreateString(sender) : 0);
}

struct AssetQuery FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBKEY = 4,
    VT_LEDGER_NAME = 6,
    VT_DOMAIN_NAME = 8,
    VT_ASSET_NAME = 10,
    VT_UNCOMMITTED = 12
  };
  const flatbuffers::String *pubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBKEY);
  }
  flatbuffers::String *mutable_pubKey() {
    return GetPointer<flatbuffers::String *>(VT_PUBKEY);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  flatbuffers::String *mutable_ledger_name() {
    return GetPointer<flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  flatbuffers::String *mutable_domain_name() {
    return GetPointer<flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  flatbuffers::String *mutable_asset_name() {
    return GetPointer<flatbuffers::String *>(VT_ASSET_NAME);
  }
  bool uncommitted() const {
    return GetField<uint8_t>(VT_UNCOMMITTED, 0) != 0;
  }
  bool mutate_uncommitted(bool _uncommitted) {
    return SetField<uint8_t>(VT_UNCOMMITTED, static_cast<uint8_t>(_uncommitted), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBKEY) &&
           verifier.Verify(pubKey()) &&
           VerifyOffset(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyOffset(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyOffset(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyField<uint8_t>(verifier, VT_UNCOMMITTED) &&
           verifier.EndTable();
  }
};

struct AssetQueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pubKey(flatbuffers::Offset<flatbuffers::String> pubKey) {
    fbb_.AddOffset(AssetQuery::VT_PUBKEY, pubKey);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(AssetQuery::VT_LEDGER_NAME, ledger_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(AssetQuery::VT_DOMAIN_NAME, domain_name);
  }
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(AssetQuery::VT_ASSET_NAME, asset_name);
  }
  void add_uncommitted(bool uncommitted) {
    fbb_.AddElement<uint8_t>(AssetQuery::VT_UNCOMMITTED, static_cast<uint8_t>(uncommitted), 0);
  }
  AssetQueryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetQueryBuilder &operator=(const AssetQueryBuilder &);
  flatbuffers::Offset<AssetQuery> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<AssetQuery>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetQuery> CreateAssetQuery(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pubKey = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    bool uncommitted = false) {
  AssetQueryBuilder builder_(_fbb);
  builder_.add_asset_name(asset_name);
  builder_.add_domain_name(domain_name);
  builder_.add_ledger_name(ledger_name);
  builder_.add_pubKey(pubKey);
  builder_.add_uncommitted(uncommitted);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetQuery> CreateAssetQueryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pubKey = nullptr,
    const char *ledger_name = nullptr,
    const char *domain_name = nullptr,
    const char *asset_name = nullptr,
    bool uncommitted = false) {
  return iroha::CreateAssetQuery(
      _fbb,
      pubKey ? _fbb.CreateString(pubKey) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      uncommitted);
}

struct AssetResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_CODE = 6,
    VT_ASSETS = 8
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  iroha::Code code() const {
    return static_cast<iroha::Code>(GetField<uint8_t>(VT_CODE, 0));
  }
  bool mutate_code(iroha::Code _code) {
    return SetField<uint8_t>(VT_CODE, static_cast<uint8_t>(_code), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *assets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *>(VT_ASSETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *mutable_assets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>> *>(VT_ASSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_ASSETS) &&
           verifier.Verify(assets()) &&
           verifier.VerifyVectorOfTables(assets()) &&
           verifier.EndTable();
  }
};

struct AssetResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(AssetResponse::VT_MESSAGE, message);
  }
  void add_code(iroha::Code code) {
    fbb_.AddElement<uint8_t>(AssetResponse::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_assets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> assets) {
    fbb_.AddOffset(AssetResponse::VT_ASSETS, assets);
  }
  AssetResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetResponseBuilder &operator=(const AssetResponseBuilder &);
  flatbuffers::Offset<AssetResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AssetResponse>(end);
    fbb_.Required(o, AssetResponse::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<AssetResponse> CreateAssetResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    iroha::Code code = iroha::Code::COMMIT,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Asset>>> assets = 0) {
  AssetResponseBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetResponse> CreateAssetResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    iroha::Code code = iroha::Code::COMMIT,
    const std::vector<flatbuffers::Offset<iroha::Asset>> *assets = nullptr) {
  return iroha::CreateAssetResponse(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      code,
      assets ? _fbb.CreateVector<flatbuffers::Offset<iroha::Asset>>(*assets) : 0);
}

struct TxWithIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TX = 4,
    VT_INDEX = 6
  };
  const iroha::Transaction *tx() const {
    return GetPointer<const iroha::Transaction *>(VT_TX);
  }
  iroha::Transaction *mutable_tx() {
    return GetPointer<iroha::Transaction *>(VT_TX);
  }
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint64_t _index) {
    return SetField<uint64_t>(VT_INDEX, _index, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TX) &&
           verifier.VerifyTable(tx()) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct TxWithIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tx(flatbuffers::Offset<iroha::Transaction> tx) {
    fbb_.AddOffset(TxWithIndex::VT_TX, tx);
  }
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(TxWithIndex::VT_INDEX, index, 0);
  }
  TxWithIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TxWithIndexBuilder &operator=(const TxWithIndexBuilder &);
  flatbuffers::Offset<TxWithIndex> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TxWithIndex>(end);
    fbb_.Required(o, TxWithIndex::VT_TX);
    return o;
  }
};

inline flatbuffers::Offset<TxWithIndex> CreateTxWithIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::Transaction> tx = 0,
    uint64_t index = 0) {
  TxWithIndexBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_tx(tx);
  return builder_.Finish();
}

struct TxRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4,
    VT_SENDER = 6
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint64_t _index) {
    return SetField<uint64_t>(VT_INDEX, _index, 0);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  flatbuffers::String *mutable_sender() {
    return GetPointer<flatbuffers::String *>(VT_SENDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyOffsetRequired(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           verifier.EndTable();
  }
};

struct TxRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(TxRequest::VT_INDEX, index, 0);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(TxRequest::VT_SENDER, sender);
  }
  TxRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TxRequestBuilder &operator=(const TxRequestBuilder &);
  flatbuffers::Offset<TxRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TxRequest>(end);
    fbb_.Required(o, TxRequest::VT_SENDER);
    return o;
  }
};

inline flatbuffers::Offset<TxRequest> CreateTxRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0) {
  TxRequestBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_sender(sender);
  return builder_.Finish();
}

inline flatbuffers::Offset<TxRequest> CreateTxRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    const char *sender = nullptr) {
  return iroha::CreateTxRequest(
      _fbb,
      index,
      sender ? _fbb.CreateString(sender) : 0);
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_ENDPOINT_IROHA_H_
