syntax = "proto3";
package iroha.protocol;
import "primitive.proto";


message Asset {
  // defines visibility for asset in nested domains (like class inheritance)
  enum Visibility {
    public     = 0;  // everyone from any domain can use this asset
    protected  = 1;  // everyone in nested domains (subdomains) can use this asset
    private    = 2;  // accounts only in given domain can use this asset
  }

  // transaction creator should have permissions to create assets in domains
  message Create {
    // asset_id will be: <name>#<domain>, example: USD#sberkek.ru
    string name   = 1;
    string domain = 2;
    // optional, JSON-encoded data to create complex assets. Description of asset can be placed here as well.
    string data   = 3;
    // defines default visibility for asset in nested domains (like class inheritance)
    Visibility visibility = 4;
    // if asset is open, then everyone can create wallet with this asset.
    // if asset is closed, then only creator (or accounts with according permissions) can create wallets with this asset
    bool   isOpen = 5;
    // Precision for asset representation
    uint32 precision = 6;

  }
}

message Wallet {

  enum Premissions{
    add = 0; // permission to add assets to this wallet
    remove = 1; // permission to remove wallet
    transfer = 2; // permision to transfer
  }

  // create wallet with given asset, by default it will have amount = 0.0
  // Wallet creator "account" must have presmission to create a wallet
  message Create {
    string wallet_id = 1;
    // Full asset name like domain#asset_name
    string asset_name = 2;
  }

  // Assign ownership of wallet "wallet_id" to accout "account_id" with permissions
  message AssignWallet {
    string account_id = 1;
    string wallet_id = 2;
    uint32 permissions = 3; // Logical or of premissions
  }

  // Transfer from one wallet to another
  // Wallet can have only one asset type.
  // If wallet sender asset is not the same as in reciever - Exchange will be executed
  message Transfer {
    string sender_wallet_id = 1;
    string reciever_wallet_id = 2;
    uint64 amount = 3;
  }

  // Add amount of asset of the wallet with id "wallet_id"
  message Add {
    string wallet_id = 1;
    uint64 amount  = 2;
  }

  message Subtract {
    string wallet_id = 1;
    uint64 amount = 2;
  }
  // Account must have permission to close this wallet
  message CloseWallet {
    string account_id = 1;
    string wallet_id = 2;
  }
}


message Domain {
  // create new domain
  message Create {
    string domain = 1; // full domain name, soramitsu.co.jp for example
    // if domain is open, then any user can join the domain.
    // in closed domains accounts can be added only by invite
    bool   isOpen = 2;
  }

  // note: you can remove only empty domains (without assets and accounts)
  message Remove {
    string domain = 1; // full domain name
  }

  // usage example ( | is logical or):
  // uint32 p = createAsset | createSubdomain | inviteAccounts
  enum Permissions {
    noPermissions   = 0;
    createAsset     = 1;
    createSubdomain = 2;  // create
    inviteAccounts  = 4;  // invite other accounts to this domain
    givePermissions = 8;  // account with this permission is able to give any permission to other account
    removeAccountsFromDomain = 16; // account with this permission is able to remove any other account from a domain
  }

  // transaction "creator" invites account with account_uuid to the domain
  message InviteAccount {
    string account_uuid = 1; // account uuid
    string domain       = 2; // invite to this domain
    uint32 permissions  = 3; // logical or of Permissions enum
    string username     = 4; // account will join with this username: <username>@soramitsu.co.jp
  }

  // remove account from a domain (creator should have according permissions)
  // this is for domain admins to kick accounts from a domain
  message RemoveAccount {
    string account_uuid = 1;
    string domain       = 2;
  }

  // set permissions for the account in domain
  message SetPermissions {
    string account_uuid = 1;
    uint32 permissions  = 2;
  }
}


message Account {
  // create new account with quorum and signatories
  message Create {
    uint32             quorum  = 1;
    repeated Signature sigs    = 2;
  }

  enum State {
    active = 0;
    suspended = 1;  // banned
    // not_approved = 2; // whatever
  }

  // set account state
  message SetState {
    string uuid = 1;
    State state = 2;
  }

  // account who created transaction ("creator") joins a domain
  message JoinDomain {
    string domain       = 1;
    string username     = 2;
  }

  // account who created transaction ("creator") leaves domain
  message LeaveDomain {
    string domain   = 1;
  }
}



message Peer {
  enum Role {
    validator = 0;  // now all peers are validators, but this is for future versions
    member = 1;
  }

  // add peer to the network
  message Add {
    string ip     = 1;
    string pubkey = 2;
    Role role     = 3;
  }

  // remove peer from the network
  message Remove {
    string pubkey = 1;
  }

  // set peer role in the network
  message SetRole {
    string pubkey = 1;
    Role role     = 2;
  }
}




message Command {
  // Asset Commands
  message AssetCommand{
    oneof asset_command {

      Wallet.Add           wallet_add      = 1;
      Wallet.Subtract      wallet_subtract = 2;
      // Exchange is the same transfer
      Wallet.Transfer      wallet_transfer = 3;
      Wallet.AssignWallet  wallet_assign = 4;
      Wallet.Create        wallet_create = 5;
      // Create specific asset
      Asset.Create         asset_create = 6;
    }
  }

  // Account Commands
  message AccountCommand {
    oneof account_command {
      // Account
      Account.Create      account_create = 1;
      Account.SetState    account_set_state = 2;
      Account.JoinDomain  account_join_domain = 3;
      Account.LeaveDomain account_leave = 4;
    }
  }

  // DomainCommand
  message DomainCommand {
    oneof domain_command {
      // Create new domain
      Domain.Create           domain_create  = 1;
      // Remove domain. Will work only for empty domain!
      Domain.Remove           domain_remove  = 2;
      // Invite account to domain
      Domain.InviteAccount    account_invite_domain = 3;
      // Remove account from domain
      Domain.RemoveAccount    account_remove_domain = 4;
      // Set permission for domain in account
      Domain.SetPermissions   account_set_permission = 5;
    }
  }

  // PeerCommand
  message PeerCommand {
    oneof peer_command {
      Peer.Add              peer_add              = 1;
      Peer.Remove           peer_remove           = 2;
      Peer.SetRole          peer_set_state        = 3;
    }
  }
  oneof command {
    AssetCommand    asset_command   = 1;
    AccountCommand  account_command = 2;
    DomainCommand   domain_command  = 3;
    PeerCommand     peer_command    = 4;
  }
}