syntax = "proto3";
package iroha.protocol;
import "asset.proto";
import "primitive.proto";

// AssetCommand
message Add{
    string to_account = 1;
    Asset asset       = 2;
}
message Subtract{
    string to_account = 1;
    Asset asset       = 2;
}
message Transfer{
    string sender    = 1;
    string receiver  = 2;
    Asset asset      = 3;
}
// ToDo
message Exchange{}

message AssetSetPermission{
    string domain_id   = 1;
    string account_id  = 2;
    bytes  permissions = 3;
}

// AccountCommand
message SignatoriesRegister{
    string to_account = 1;
    repeated Signature signatories = 2;
}
message SignatoriesUnregister{
    string from_account = 1;
    repeated Signature signatories = 2;
}
message SetQuorum{
    string target_account = 1;
    uint32 quorum = 2;
}
message AccountGrant{
    string to_account = 1;
}
message AccountDeprive{
    string from_account = 1;
}


// DomainCommand
message AssetCreate{
    string to_domain = 1;
    Asset asset = 2;
}
message DomainCreate{
    string domain = 1;
    string root_account = 2;
}

message AccountCreate{
    string username = 1;
    repeated Signature signatories = 2;
    uint32 quorum = 3;
    string domain = 4;
}
message AccountSuspend{
    string target_account = 1;
}
message AccountRegister{
    string target_account = 1;
    string to_domain = 2;
    bytes  permissions = 3;
}
message AccountUnregister{
    string target_account = 1;
}

message DomainSetPermission{
    string domain_id   = 1;
    string account_id  = 2;
    bytes  permissions = 3;
}
message DomainSetNotify{
    string target_address = 1;
}


message Asset {
    // defines visibility for asset in nested domains (like class inheritance)
    enum Visibility {
        public     = 0;  // everyone from any domain can use this asset
        protected  = 1;  // everyone in nested domains (subdomains) can use this asset
        private    = 2;  // accounts only in given domain can use this asset
    }

    // transaction creator should have permissions to create assets in domains
    message Create {
        // asset_id will be: <name>#<domain>, example: USD#sberkek.ru
        string name   = 1;
        string domain = 2;
        // optional, JSON-encoded data to create complex assets. Description of asset can be placed here as well.
        string data   = 3;
        // defines default visibility for asset in nested domains (like class inheritance)
        Visibility visibility = 4;
        // if asset is open, then everyone can create wallet with this asset.
        // if asset is closed, then only creator (or accounts with according permissions) can create wallets with this asset
        bool   isOpen = 5;
        // Precision for asset representation
        uint32 precision = 6;

    }
}

message Wallet {

    enum Premissions{
        add = 0; // add assets to this wallet
        remove = 1; //
    }

    // create wallet with given asset, by default it will have amount = 0.0
    // Wallet creator "account" must have presmission to create a wallet
    message Create {
        string wallet_id = 1;
        // Full asset name like domain#asset_name
        string asset_name = 2;
    }

    // Assign ownership of wallet "wallet_id" to accout "account_id" with permissions
    message AssignWallet {
        string account_id = 1;
        string wallet_id = 2;
        uint32 permissions = 3; // Logical or of premissions
    }
}


message Domain {
    // create new domain
    message Create {
        string domain = 1; // full domain name, soramitsu.co.jp for example
        // if domain is open, then any user can join the domain.
        // in closed domains accounts can be added only by invite
        bool   isOpen = 2;
    }

    // note: you can remove only empty domains (without assets and accounts)
    message Remove {
        string domain = 1; // full domain name
    }

    // usage example ( | is logical or):
    // uint32 p = createAsset | createSubdomain | inviteAccounts
    enum Permissions {
        noPermissions   = 0;
        createAsset     = 1;
        createSubdomain = 2;  // create
        inviteAccounts  = 4;  // invite other accounts to this domain
        givePermissions = 8;  // account with this permission is able to give any permission to other account
        removeAccountsFromDomain = 16; // account with this permission is able to remove any other account from a domain
    }

    // transaction "creator" invites account with account_uuid to the domain
    message InviteAccount {
        string account_uuid = 1; // account uuid
        string domain       = 2; // invite to this domain
        uint32 permissions  = 3; // logical or of Permissions enum
        string username     = 4; // account will join with this username: <username>@soramitsu.co.jp
    }

    // remove account from a domain (creator should have according permissions)
    // this is for domain admins to kick accounts from a domain
    message RemoveAccount {
        string account_uuid = 1;
        string domain       = 2;
    }

    // set permissions for the account in domain
    message SetPermissions {
        string account_uuid = 1;
        uint32 permissions  = 2;
    }
}


message Account {
    // create new account with quorum and signatories
    message Create {
        uint32             quorum  = 1;
        repeated Signature sigs    = 2;
    }

    enum State {
        active = 0;
        suspended = 1;  // banned
        // not_approved = 2; // whatever
    }

    // set account state
    message SetState {
        string uuid = 1;
        State state = 2;
    }

    // account who created transaction ("creator") joins a domain
    message JoinDomain {
        string domain       = 1;
        string username     = 2;
    }

    // account who created transaction ("creator") leaves domain
    message LeaveDomain {
        string domain   = 1;
    }
}



message Peer {
    enum Role {
        validator = 0;  // now all peers are validators, but this is for future versions
        member = 1;
    }

    // add peer to the network
    message Add {
        string ip     = 1;
        string pubkey = 2;
        Role role     = 3;
    }

    // remove peer from the network
    message Remove {
        string pubkey = 1;
    }

    // set peer role in the network
    message SetRole {
        string pubkey = 1;
        Role role     = 2;
    }
}




message Command {
    // AssetCommand
    message AssetCommand{
        oneof asset_command {
            Add         add      = 1;
            Subtract    subtract = 2;
            Transfer    transfer = 3;
            Exchange    exchange = 4;
            AssetSetPermission asset_set_permission = 5;
        }
    }

    // AccountCommand
    message AccountCommand {
        oneof account_command {
            SignatoriesRegister    signatories_register   = 1;
            SignatoriesUnregister  signatories_unregister = 2;
            SetQuorum              set_quorum             = 3;
            AccountGrant           account_grant          = 4;
            AccountDeprive         account_deprive        = 5;
        }
    }

    // DomainCommand
    message DomainCommand {
        oneof domain_command {
            // Add asset as concept(type?) to domain
            // If add asset as wallet to user, use AssetCommand::Add.
            AssetCreate           asset_create         = 1;
            DomainCreate          domain_create        = 2;

            AccountCreate         account_create       = 3;
            AccountSuspend        account_delete       = 4;
            AccountRegister       account_register     = 5;
            AccountUnregister     account_unregister   = 6;

            DomainSetPermission   domain_set_permission = 7;
            DomainSetNotify       domain_set_notify     = 8;
        }
    }

    // PeerCommand
    message PeerCommand {
        oneof peer_command {
            Peer.Add              peer_add              = 1;
            Peer.Remove           peer_remove           = 2;
            Peer.SetRole          peer_set_state        = 3;
        }
    }
    oneof command {
        AssetCommand    asset_command   = 1;
        AccountCommand  account_command = 2;
        DomainCommand   domain_command  = 3;
        PeerCommand     peer_command    = 4;
    }
}