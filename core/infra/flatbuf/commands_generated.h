// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_
#define FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "key_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct CmdAdd;

struct CmdRemove;

struct CmdStore;

struct CmdTransfer;

struct CmdAddAsset;

struct CmdRemoveAsset;

struct CmdCreateAsset;

struct CmdExecute;

struct CmdSetChaincode;

struct CmdSetPeerTrust;

struct CmdChangePeerTrust;

struct CmdSetPeerActive;

struct CmdAddSignatory;

struct CmdSetAccountsUseKeys;

enum Object {
  Object_NONE = 0,
  Object_Peer = 1,
  Object_Account = 2,
  Object_Chaincode = 3,
  Object_MIN = Object_NONE,
  Object_MAX = Object_Chaincode
};

inline const char **EnumNamesObject() {
  static const char *names[] = {
    "NONE",
    "Peer",
    "Account",
    "Chaincode",
    nullptr
  };
  return names;
}

inline const char *EnumNameObject(Object e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObject()[index];
}

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object_NONE;
};

template<> struct ObjectTraits<iroha::Peer> {
  static const Object enum_value = Object_Peer;
};

template<> struct ObjectTraits<iroha::Account> {
  static const Object enum_value = Object_Account;
};

template<> struct ObjectTraits<iroha::Chaincode> {
  static const Object enum_value = Object_Chaincode;
};

bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type);
bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

//////////////////////////////////////////
enum Command {
  Command_NONE = 0,
  Command_CmdAddAsset = 1,
  Command_CmdRemoveAsset = 2,
  Command_CmdCreateAsset = 3,
  Command_CmdTransfer = 4,
  Command_CmdAdd = 5,
  Command_CmdRemove = 6,
  Command_CmdExecute = 7,
  Command_CmdStore = 8,
  Command_CmdSetPeerTrust = 9,
  Command_CmdChangePeerTrust = 10,
  Command_CmdSetPeerActive = 11,
  Command_CmdSetChaincode = 12,
  Command_CmdSetAccountsUseKeys = 13,
  Command_MIN = Command_NONE,
  Command_MAX = Command_CmdSetAccountsUseKeys
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "CmdAddAsset",
    "CmdRemoveAsset",
    "CmdCreateAsset",
    "CmdTransfer",
    "CmdAdd",
    "CmdRemove",
    "CmdExecute",
    "CmdStore",
    "CmdSetPeerTrust",
    "CmdChangePeerTrust",
    "CmdSetPeerActive",
    "CmdSetChaincode",
    "CmdSetAccountsUseKeys",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<CmdAddAsset> {
  static const Command enum_value = Command_CmdAddAsset;
};

template<> struct CommandTraits<CmdRemoveAsset> {
  static const Command enum_value = Command_CmdRemoveAsset;
};

template<> struct CommandTraits<CmdCreateAsset> {
  static const Command enum_value = Command_CmdCreateAsset;
};

template<> struct CommandTraits<CmdTransfer> {
  static const Command enum_value = Command_CmdTransfer;
};

template<> struct CommandTraits<CmdAdd> {
  static const Command enum_value = Command_CmdAdd;
};

template<> struct CommandTraits<CmdRemove> {
  static const Command enum_value = Command_CmdRemove;
};

template<> struct CommandTraits<CmdExecute> {
  static const Command enum_value = Command_CmdExecute;
};

template<> struct CommandTraits<CmdStore> {
  static const Command enum_value = Command_CmdStore;
};

template<> struct CommandTraits<CmdSetPeerTrust> {
  static const Command enum_value = Command_CmdSetPeerTrust;
};

template<> struct CommandTraits<CmdChangePeerTrust> {
  static const Command enum_value = Command_CmdChangePeerTrust;
};

template<> struct CommandTraits<CmdSetPeerActive> {
  static const Command enum_value = Command_CmdSetPeerActive;
};

template<> struct CommandTraits<CmdSetChaincode> {
  static const Command enum_value = Command_CmdSetChaincode;
};

template<> struct CommandTraits<CmdSetAccountsUseKeys> {
  static const Command enum_value = Command_CmdSetAccountsUseKeys;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CmdAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const iroha::Peer *object_as_Peer() const {
    return (object_type() == Object_Peer)? static_cast<const iroha::Peer *>(object()) : nullptr;
  }
  const iroha::Account *object_as_Account() const {
    return (object_type() == Object_Account)? static_cast<const iroha::Account *>(object()) : nullptr;
  }
  const iroha::Chaincode *object_as_Chaincode() const {
    return (object_type() == Object_Chaincode)? static_cast<const iroha::Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::Peer *CmdAdd::object_as<iroha::Peer>() const {
  return object_as_Peer();
}

template<> inline const iroha::Account *CmdAdd::object_as<iroha::Account>() const {
  return object_as_Account();
}

template<> inline const iroha::Chaincode *CmdAdd::object_as<iroha::Chaincode>() const {
  return object_as_Chaincode();
}

struct CmdAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(CmdAdd::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(CmdAdd::VT_OBJECT, object);
  }
  CmdAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdAddBuilder &operator=(const CmdAddBuilder &);
  flatbuffers::Offset<CmdAdd> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdAdd>(end);
    fbb_.Required(o, CmdAdd::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<CmdAdd> CreateCmdAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  CmdAddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct CmdRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const iroha::Peer *object_as_Peer() const {
    return (object_type() == Object_Peer)? static_cast<const iroha::Peer *>(object()) : nullptr;
  }
  const iroha::Account *object_as_Account() const {
    return (object_type() == Object_Account)? static_cast<const iroha::Account *>(object()) : nullptr;
  }
  const iroha::Chaincode *object_as_Chaincode() const {
    return (object_type() == Object_Chaincode)? static_cast<const iroha::Chaincode *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::Peer *CmdRemove::object_as<iroha::Peer>() const {
  return object_as_Peer();
}

template<> inline const iroha::Account *CmdRemove::object_as<iroha::Account>() const {
  return object_as_Account();
}

template<> inline const iroha::Chaincode *CmdRemove::object_as<iroha::Chaincode>() const {
  return object_as_Chaincode();
}

struct CmdRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(CmdRemove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(CmdRemove::VT_OBJECT, object);
  }
  CmdRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdRemoveBuilder &operator=(const CmdRemoveBuilder &);
  flatbuffers::Offset<CmdRemove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdRemove>(end);
    fbb_.Required(o, CmdRemove::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<CmdRemove> CreateCmdRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  CmdRemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct CmdStore FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_DATA = 6
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct CmdStoreBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(CmdStore::VT_ACCPUBKEY, accPubKey);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data) {
    fbb_.AddOffset(CmdStore::VT_DATA, data);
  }
  CmdStoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdStoreBuilder &operator=(const CmdStoreBuilder &);
  flatbuffers::Offset<CmdStore> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdStore>(end);
    fbb_.Required(o, CmdStore::VT_ACCPUBKEY);
    fbb_.Required(o, CmdStore::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<CmdStore> CreateCmdStore(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data = 0) {
  CmdStoreBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdStore> CreateCmdStoreDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<flatbuffers::Offset<iroha::KeyValueObject>> *data = nullptr) {
  return iroha::CreateCmdStore(
      _fbb,
      accPubKey,
      data ? _fbb.CreateVector<flatbuffers::Offset<iroha::KeyValueObject>>(*data) : 0);
}

struct CmdTransfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENCY = 4,
    VT_SENDER = 6,
    VT_RECEIVER = 8
  };
  const iroha::Asset *currency() const {
    return GetPointer<const iroha::Asset *>(VT_CURRENCY);
  }
  const iroha::PublicKey *sender() const {
    return GetPointer<const iroha::PublicKey *>(VT_SENDER);
  }
  const iroha::PublicKey *receiver() const {
    return GetPointer<const iroha::PublicKey *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CURRENCY) &&
           verifier.VerifyTable(currency()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.VerifyTable(sender()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.VerifyTable(receiver()) &&
           verifier.EndTable();
  }
};

struct CmdTransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency(flatbuffers::Offset<iroha::Asset> currency) {
    fbb_.AddOffset(CmdTransfer::VT_CURRENCY, currency);
  }
  void add_sender(flatbuffers::Offset<iroha::PublicKey> sender) {
    fbb_.AddOffset(CmdTransfer::VT_SENDER, sender);
  }
  void add_receiver(flatbuffers::Offset<iroha::PublicKey> receiver) {
    fbb_.AddOffset(CmdTransfer::VT_RECEIVER, receiver);
  }
  CmdTransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdTransferBuilder &operator=(const CmdTransferBuilder &);
  flatbuffers::Offset<CmdTransfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CmdTransfer>(end);
    fbb_.Required(o, CmdTransfer::VT_CURRENCY);
    fbb_.Required(o, CmdTransfer::VT_SENDER);
    fbb_.Required(o, CmdTransfer::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<CmdTransfer> CreateCmdTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::Asset> currency = 0,
    flatbuffers::Offset<iroha::PublicKey> sender = 0,
    flatbuffers::Offset<iroha::PublicKey> receiver = 0) {
  CmdTransferBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  builder_.add_sender(sender);
  builder_.add_currency(currency);
  return builder_.Finish();
}

//////////////////////////////////////////
/// Commands for Asset
struct CmdAddAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET_TYPE = 6,
    VT_ASSET = 8
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *asset_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASSET_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASSET_TYPE) &&
           verifier.Verify(asset_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           VerifyAnyAssetVector(verifier, asset(), asset_type()) &&
           verifier.EndTable();
  }
};

struct CmdAddAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(CmdAddAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset_type) {
    fbb_.AddOffset(CmdAddAsset::VT_ASSET_TYPE, asset_type);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> asset) {
    fbb_.AddOffset(CmdAddAsset::VT_ASSET, asset);
  }
  CmdAddAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdAddAssetBuilder &operator=(const CmdAddAssetBuilder &);
  flatbuffers::Offset<CmdAddAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CmdAddAsset>(end);
    fbb_.Required(o, CmdAddAsset::VT_ACCPUBKEY);
    fbb_.Required(o, CmdAddAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<CmdAddAsset> CreateCmdAddAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> asset = 0) {
  CmdAddAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_asset_type(asset_type);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdAddAsset> CreateCmdAddAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<uint8_t> *asset_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *asset = nullptr) {
  return iroha::CreateCmdAddAsset(
      _fbb,
      accPubKey,
      asset_type ? _fbb.CreateVector<uint8_t>(*asset_type) : 0,
      asset ? _fbb.CreateVector<flatbuffers::Offset<void>>(*asset) : 0);
}

struct CmdRemoveAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET_TYPE = 6,
    VT_ASSET = 8
  };
  const iroha::PublicKey *accPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *asset_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASSET_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *asset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ASSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.VerifyTable(accPubKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASSET_TYPE) &&
           verifier.Verify(asset_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           VerifyAnyAssetVector(verifier, asset(), asset_type()) &&
           verifier.EndTable();
  }
};

struct CmdRemoveAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<iroha::PublicKey> accPubKey) {
    fbb_.AddOffset(CmdRemoveAsset::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset_type) {
    fbb_.AddOffset(CmdRemoveAsset::VT_ASSET_TYPE, asset_type);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> asset) {
    fbb_.AddOffset(CmdRemoveAsset::VT_ASSET, asset);
  }
  CmdRemoveAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdRemoveAssetBuilder &operator=(const CmdRemoveAssetBuilder &);
  flatbuffers::Offset<CmdRemoveAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CmdRemoveAsset>(end);
    fbb_.Required(o, CmdRemoveAsset::VT_ACCPUBKEY);
    fbb_.Required(o, CmdRemoveAsset::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<CmdRemoveAsset> CreateCmdRemoveAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> asset = 0) {
  CmdRemoveAssetBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_asset_type(asset_type);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdRemoveAsset> CreateCmdRemoveAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> accPubKey = 0,
    const std::vector<uint8_t> *asset_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *asset = nullptr) {
  return iroha::CreateCmdRemoveAsset(
      _fbb,
      accPubKey,
      asset_type ? _fbb.CreateVector<uint8_t>(*asset_type) : 0,
      asset ? _fbb.CreateVector<flatbuffers::Offset<void>>(*asset) : 0);
}

struct CmdCreateAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_DESCRIPTION = 10
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.Verify(description()) &&
           verifier.EndTable();
  }
};

struct CmdCreateAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(CmdCreateAsset::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(CmdCreateAsset::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(CmdCreateAsset::VT_LEDGER_NAME, ledger_name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(CmdCreateAsset::VT_DESCRIPTION, description);
  }
  CmdCreateAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdCreateAssetBuilder &operator=(const CmdCreateAssetBuilder &);
  flatbuffers::Offset<CmdCreateAsset> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CmdCreateAsset>(end);
    fbb_.Required(o, CmdCreateAsset::VT_ASSET_NAME);
    fbb_.Required(o, CmdCreateAsset::VT_DOMAIN_NAME);
    fbb_.Required(o, CmdCreateAsset::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<CmdCreateAsset> CreateCmdCreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0) {
  CmdCreateAssetBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdCreateAsset> CreateCmdCreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *description = nullptr) {
  return iroha::CreateCmdCreateAsset(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      description ? _fbb.CreateString(description) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Chaincode
struct CmdExecute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8
  };
  const flatbuffers::String *code_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE_NAME) &&
           verifier.Verify(code_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           verifier.EndTable();
  }
};

struct CmdExecuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code_name(flatbuffers::Offset<flatbuffers::String> code_name) {
    fbb_.AddOffset(CmdExecute::VT_CODE_NAME, code_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(CmdExecute::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(CmdExecute::VT_LEDGER_NAME, ledger_name);
  }
  CmdExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdExecuteBuilder &operator=(const CmdExecuteBuilder &);
  flatbuffers::Offset<CmdExecute> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CmdExecute>(end);
    fbb_.Required(o, CmdExecute::VT_CODE_NAME);
    fbb_.Required(o, CmdExecute::VT_DOMAIN_NAME);
    fbb_.Required(o, CmdExecute::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<CmdExecute> CreateCmdExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0) {
  CmdExecuteBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_code_name(code_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdExecute> CreateCmdExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr) {
  return iroha::CreateCmdExecute(
      _fbb,
      code_name ? _fbb.CreateString(code_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0);
}

struct CmdSetChaincode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHAINCODE = 4
  };
  const iroha::Chaincode *chaincode() const {
    return GetPointer<const iroha::Chaincode *>(VT_CHAINCODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CHAINCODE) &&
           verifier.VerifyTable(chaincode()) &&
           verifier.EndTable();
  }
};

struct CmdSetChaincodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chaincode(flatbuffers::Offset<iroha::Chaincode> chaincode) {
    fbb_.AddOffset(CmdSetChaincode::VT_CHAINCODE, chaincode);
  }
  CmdSetChaincodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdSetChaincodeBuilder &operator=(const CmdSetChaincodeBuilder &);
  flatbuffers::Offset<CmdSetChaincode> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CmdSetChaincode>(end);
    fbb_.Required(o, CmdSetChaincode::VT_CHAINCODE);
    return o;
  }
};

inline flatbuffers::Offset<CmdSetChaincode> CreateCmdSetChaincode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::Chaincode> chaincode = 0) {
  CmdSetChaincodeBuilder builder_(_fbb);
  builder_.add_chaincode(chaincode);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Peer
struct CmdSetPeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_TRUST = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  double trust() const {
    return GetField<double>(VT_TRUST, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_TRUST) &&
           verifier.EndTable();
  }
};

struct CmdSetPeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(CmdSetPeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_trust(double trust) {
    fbb_.AddElement<double>(CmdSetPeerTrust::VT_TRUST, trust, 0.0);
  }
  CmdSetPeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdSetPeerTrustBuilder &operator=(const CmdSetPeerTrustBuilder &);
  flatbuffers::Offset<CmdSetPeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdSetPeerTrust>(end);
    fbb_.Required(o, CmdSetPeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<CmdSetPeerTrust> CreateCmdSetPeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    double trust = 0.0) {
  CmdSetPeerTrustBuilder builder_(_fbb);
  builder_.add_trust(trust);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct CmdChangePeerTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_DELTA = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  double delta() const {
    return GetField<double>(VT_DELTA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<double>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct CmdChangePeerTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(CmdChangePeerTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_delta(double delta) {
    fbb_.AddElement<double>(CmdChangePeerTrust::VT_DELTA, delta, 0.0);
  }
  CmdChangePeerTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdChangePeerTrustBuilder &operator=(const CmdChangePeerTrustBuilder &);
  flatbuffers::Offset<CmdChangePeerTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdChangePeerTrust>(end);
    fbb_.Required(o, CmdChangePeerTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<CmdChangePeerTrust> CreateCmdChangePeerTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    double delta = 0.0) {
  CmdChangePeerTrustBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

struct CmdSetPeerActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_ACTIVE = 6
  };
  const iroha::PublicKey *peerPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_PEERPUBKEY);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.VerifyTable(peerPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           verifier.EndTable();
  }
};

struct CmdSetPeerActiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<iroha::PublicKey> peerPubKey) {
    fbb_.AddOffset(CmdSetPeerActive::VT_PEERPUBKEY, peerPubKey);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(CmdSetPeerActive::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  CmdSetPeerActiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdSetPeerActiveBuilder &operator=(const CmdSetPeerActiveBuilder &);
  flatbuffers::Offset<CmdSetPeerActive> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdSetPeerActive>(end);
    fbb_.Required(o, CmdSetPeerActive::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<CmdSetPeerActive> CreateCmdSetPeerActive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> peerPubKey = 0,
    bool active = false) {
  CmdSetPeerActiveBuilder builder_(_fbb);
  builder_.add_peerPubKey(peerPubKey);
  builder_.add_active(active);
  return builder_.Finish();
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Account
struct CmdAddSignatory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4,
    VT_SIGNATORY = 6
  };
  const iroha::PublicKey *account() const {
    return GetPointer<const iroha::PublicKey *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *signatory() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *>(VT_SIGNATORY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.VerifyTable(account()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATORY) &&
           verifier.Verify(signatory()) &&
           verifier.VerifyVectorOfTables(signatory()) &&
           verifier.EndTable();
  }
};

struct CmdAddSignatoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<iroha::PublicKey> account) {
    fbb_.AddOffset(CmdAddSignatory::VT_ACCOUNT, account);
  }
  void add_signatory(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> signatory) {
    fbb_.AddOffset(CmdAddSignatory::VT_SIGNATORY, signatory);
  }
  CmdAddSignatoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdAddSignatoryBuilder &operator=(const CmdAddSignatoryBuilder &);
  flatbuffers::Offset<CmdAddSignatory> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdAddSignatory>(end);
    fbb_.Required(o, CmdAddSignatory::VT_ACCOUNT);
    fbb_.Required(o, CmdAddSignatory::VT_SIGNATORY);
    return o;
  }
};

inline flatbuffers::Offset<CmdAddSignatory> CreateCmdAddSignatory(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> signatory = 0) {
  CmdAddSignatoryBuilder builder_(_fbb);
  builder_.add_signatory(signatory);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdAddSignatory> CreateCmdAddSignatoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> account = 0,
    const std::vector<flatbuffers::Offset<iroha::PublicKey>> *signatory = nullptr) {
  return iroha::CreateCmdAddSignatory(
      _fbb,
      account,
      signatory ? _fbb.CreateVector<flatbuffers::Offset<iroha::PublicKey>>(*signatory) : 0);
}

struct CmdSetAccountsUseKeys FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTS = 4,
    VT_USEKEYS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>> *>(VT_ACCOUNTS);
  }
  uint16_t useKeys() const {
    return GetField<uint16_t>(VT_USEKEYS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNTS) &&
           verifier.Verify(accounts()) &&
           verifier.VerifyVectorOfTables(accounts()) &&
           VerifyField<uint16_t>(verifier, VT_USEKEYS) &&
           verifier.EndTable();
  }
};

struct CmdSetAccountsUseKeysBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> accounts) {
    fbb_.AddOffset(CmdSetAccountsUseKeys::VT_ACCOUNTS, accounts);
  }
  void add_useKeys(uint16_t useKeys) {
    fbb_.AddElement<uint16_t>(CmdSetAccountsUseKeys::VT_USEKEYS, useKeys, 0);
  }
  CmdSetAccountsUseKeysBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CmdSetAccountsUseKeysBuilder &operator=(const CmdSetAccountsUseKeysBuilder &);
  flatbuffers::Offset<CmdSetAccountsUseKeys> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CmdSetAccountsUseKeys>(end);
    fbb_.Required(o, CmdSetAccountsUseKeys::VT_ACCOUNTS);
    return o;
  }
};

inline flatbuffers::Offset<CmdSetAccountsUseKeys> CreateCmdSetAccountsUseKeys(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::PublicKey>>> accounts = 0,
    uint16_t useKeys = 0) {
  CmdSetAccountsUseKeysBuilder builder_(_fbb);
  builder_.add_accounts(accounts);
  builder_.add_useKeys(useKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<CmdSetAccountsUseKeys> CreateCmdSetAccountsUseKeysDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<iroha::PublicKey>> *accounts = nullptr,
    uint16_t useKeys = 0) {
  return iroha::CreateCmdSetAccountsUseKeys(
      _fbb,
      accounts ? _fbb.CreateVector<flatbuffers::Offset<iroha::PublicKey>>(*accounts) : 0,
      useKeys);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type) {
  switch (type) {
    case Object_NONE: {
      return true;
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<const iroha::Peer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<const iroha::Account *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Chaincode: {
      auto ptr = reinterpret_cast<const iroha::Chaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObject(
        verifier,  values->Get(i), types->GetEnum<Object>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_CmdAddAsset: {
      auto ptr = reinterpret_cast<const CmdAddAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdRemoveAsset: {
      auto ptr = reinterpret_cast<const CmdRemoveAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdCreateAsset: {
      auto ptr = reinterpret_cast<const CmdCreateAsset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdTransfer: {
      auto ptr = reinterpret_cast<const CmdTransfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdAdd: {
      auto ptr = reinterpret_cast<const CmdAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdRemove: {
      auto ptr = reinterpret_cast<const CmdRemove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdExecute: {
      auto ptr = reinterpret_cast<const CmdExecute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdStore: {
      auto ptr = reinterpret_cast<const CmdStore *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdSetPeerTrust: {
      auto ptr = reinterpret_cast<const CmdSetPeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdChangePeerTrust: {
      auto ptr = reinterpret_cast<const CmdChangePeerTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdSetPeerActive: {
      auto ptr = reinterpret_cast<const CmdSetPeerActive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdSetChaincode: {
      auto ptr = reinterpret_cast<const CmdSetChaincode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CmdSetAccountsUseKeys: {
      auto ptr = reinterpret_cast<const CmdSetAccountsUseKeys *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_
