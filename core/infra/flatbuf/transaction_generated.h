// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_
#define FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "commands_generated.h"
#include "key_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct Transaction;

struct Attachment;

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CREATORPUBKEY = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_SIGNATURES = 10,
    VT_HASH = 12,
    VT_ATTACHMENT = 14
  };
  const iroha::PublicKey *creatorPubKey() const {
    return GetPointer<const iroha::PublicKey *>(VT_CREATORPUBKEY);
  }
  iroha::Command command_type() const {
    return static_cast<iroha::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const iroha::CmdAddAsset *command_as_CmdAddAsset() const {
    return (command_type() == iroha::Command_CmdAddAsset)? static_cast<const iroha::CmdAddAsset *>(command()) : nullptr;
  }
  const iroha::CmdRemoveAsset *command_as_CmdRemoveAsset() const {
    return (command_type() == iroha::Command_CmdRemoveAsset)? static_cast<const iroha::CmdRemoveAsset *>(command()) : nullptr;
  }
  const iroha::CmdCreateAsset *command_as_CmdCreateAsset() const {
    return (command_type() == iroha::Command_CmdCreateAsset)? static_cast<const iroha::CmdCreateAsset *>(command()) : nullptr;
  }
  const iroha::CmdTransfer *command_as_CmdTransfer() const {
    return (command_type() == iroha::Command_CmdTransfer)? static_cast<const iroha::CmdTransfer *>(command()) : nullptr;
  }
  const iroha::CmdAdd *command_as_CmdAdd() const {
    return (command_type() == iroha::Command_CmdAdd)? static_cast<const iroha::CmdAdd *>(command()) : nullptr;
  }
  const iroha::CmdRemove *command_as_CmdRemove() const {
    return (command_type() == iroha::Command_CmdRemove)? static_cast<const iroha::CmdRemove *>(command()) : nullptr;
  }
  const iroha::CmdExecute *command_as_CmdExecute() const {
    return (command_type() == iroha::Command_CmdExecute)? static_cast<const iroha::CmdExecute *>(command()) : nullptr;
  }
  const iroha::CmdStore *command_as_CmdStore() const {
    return (command_type() == iroha::Command_CmdStore)? static_cast<const iroha::CmdStore *>(command()) : nullptr;
  }
  const iroha::CmdSetPeerTrust *command_as_CmdSetPeerTrust() const {
    return (command_type() == iroha::Command_CmdSetPeerTrust)? static_cast<const iroha::CmdSetPeerTrust *>(command()) : nullptr;
  }
  const iroha::CmdChangePeerTrust *command_as_CmdChangePeerTrust() const {
    return (command_type() == iroha::Command_CmdChangePeerTrust)? static_cast<const iroha::CmdChangePeerTrust *>(command()) : nullptr;
  }
  const iroha::CmdSetPeerActive *command_as_CmdSetPeerActive() const {
    return (command_type() == iroha::Command_CmdSetPeerActive)? static_cast<const iroha::CmdSetPeerActive *>(command()) : nullptr;
  }
  const iroha::CmdSetChaincode *command_as_CmdSetChaincode() const {
    return (command_type() == iroha::Command_CmdSetChaincode)? static_cast<const iroha::CmdSetChaincode *>(command()) : nullptr;
  }
  const iroha::CmdSetAccountsUseKeys *command_as_CmdSetAccountsUseKeys() const {
    return (command_type() == iroha::Command_CmdSetAccountsUseKeys)? static_cast<const iroha::CmdSetAccountsUseKeys *>(command()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *signatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *>(VT_SIGNATURES);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const Attachment *attachment() const {
    return GetPointer<const Attachment *>(VT_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CREATORPUBKEY) &&
           verifier.VerifyTable(creatorPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SIGNATURES) &&
           verifier.Verify(signatures()) &&
           verifier.VerifyVectorOfTables(signatures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTACHMENT) &&
           verifier.VerifyTable(attachment()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::CmdAddAsset *Transaction::command_as<iroha::CmdAddAsset>() const {
  return command_as_CmdAddAsset();
}

template<> inline const iroha::CmdRemoveAsset *Transaction::command_as<iroha::CmdRemoveAsset>() const {
  return command_as_CmdRemoveAsset();
}

template<> inline const iroha::CmdCreateAsset *Transaction::command_as<iroha::CmdCreateAsset>() const {
  return command_as_CmdCreateAsset();
}

template<> inline const iroha::CmdTransfer *Transaction::command_as<iroha::CmdTransfer>() const {
  return command_as_CmdTransfer();
}

template<> inline const iroha::CmdAdd *Transaction::command_as<iroha::CmdAdd>() const {
  return command_as_CmdAdd();
}

template<> inline const iroha::CmdRemove *Transaction::command_as<iroha::CmdRemove>() const {
  return command_as_CmdRemove();
}

template<> inline const iroha::CmdExecute *Transaction::command_as<iroha::CmdExecute>() const {
  return command_as_CmdExecute();
}

template<> inline const iroha::CmdStore *Transaction::command_as<iroha::CmdStore>() const {
  return command_as_CmdStore();
}

template<> inline const iroha::CmdSetPeerTrust *Transaction::command_as<iroha::CmdSetPeerTrust>() const {
  return command_as_CmdSetPeerTrust();
}

template<> inline const iroha::CmdChangePeerTrust *Transaction::command_as<iroha::CmdChangePeerTrust>() const {
  return command_as_CmdChangePeerTrust();
}

template<> inline const iroha::CmdSetPeerActive *Transaction::command_as<iroha::CmdSetPeerActive>() const {
  return command_as_CmdSetPeerActive();
}

template<> inline const iroha::CmdSetChaincode *Transaction::command_as<iroha::CmdSetChaincode>() const {
  return command_as_CmdSetChaincode();
}

template<> inline const iroha::CmdSetAccountsUseKeys *Transaction::command_as<iroha::CmdSetAccountsUseKeys>() const {
  return command_as_CmdSetAccountsUseKeys();
}

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_creatorPubKey(flatbuffers::Offset<iroha::PublicKey> creatorPubKey) {
    fbb_.AddOffset(Transaction::VT_CREATORPUBKEY, creatorPubKey);
  }
  void add_command_type(iroha::Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_signatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures) {
    fbb_.AddOffset(Transaction::VT_SIGNATURES, signatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  void add_attachment(flatbuffers::Offset<Attachment> attachment) {
    fbb_.AddOffset(Transaction::VT_ATTACHMENT, attachment);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_CREATORPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> creatorPubKey = 0,
    iroha::Command command_type = iroha::Command_NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<Attachment> attachment = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_attachment(attachment);
  builder_.add_hash(hash);
  builder_.add_signatures(signatures);
  builder_.add_command(command);
  builder_.add_creatorPubKey(creatorPubKey);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<iroha::PublicKey> creatorPubKey = 0,
    iroha::Command command_type = iroha::Command_NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<iroha::Signature>> *signatures = nullptr,
    const std::vector<uint8_t> *hash = nullptr,
    flatbuffers::Offset<Attachment> attachment = 0) {
  return iroha::CreateTransaction(
      _fbb,
      creatorPubKey,
      command_type,
      command,
      signatures ? _fbb.CreateVector<flatbuffers::Offset<iroha::Signature>>(*signatures) : 0,
      hash ? _fbb.CreateVector<uint8_t>(*hash) : 0,
      attachment);
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *mime() const {
    return GetPointer<const flatbuffers::String *>(VT_MIME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIME) &&
           verifier.Verify(mime()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct AttachmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mime(flatbuffers::Offset<flatbuffers::String> mime) {
    fbb_.AddOffset(Attachment::VT_MIME, mime);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attachment::VT_DATA, data);
  }
  AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBuilder &operator=(const AttachmentBuilder &);
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_mime(mime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attachment> CreateAttachmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return iroha::CreateAttachment(
      _fbb,
      mime ? _fbb.CreateString(mime) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

inline const iroha::Transaction *GetTransaction(const void *buf) {
  return flatbuffers::GetRoot<iroha::Transaction>(buf);
}

inline bool VerifyTransactionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<iroha::Transaction>(nullptr);
}

inline void FinishTransactionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<iroha::Transaction> root) {
  fbb.Finish(root);
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_
